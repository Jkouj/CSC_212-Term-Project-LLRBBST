#include <iostream>
using namespace std;



class BST {

public:

    typedef struct Node {
        struct Node *left, *right; // left and right children
        int data;                  // the element to be stored
        explicit Node(int data) {
            left = right = nullptr;
            this->data = data;
        }
    } Node;

    BST() { root = nullptr; }

    Node* search(int data) {
        Node **current = &root;
        while (*current) {
            if (data < (*current)->data) current = &(*current)->left;
            else if (data > (*current)->data) current = &(*current)->right;
            else return *current;
        }
        return nullptr;
    }

    void insert(int data) {
        Node **current = &root;
        while (*current) {
            if (data < (*current)->data) current = &(*current)->left;
            else current = &(*current)->right;
        }
        *current = new Node(data);
    }

    void delete_(int data) {
        Node* node = search(data);
        if (node == nullptr) { return; }
        bool hasLeft = node->left == nullptr, hasRight = node->right == nullptr;
        if (hasLeft) {
            if (hasRight) { replaceWithSuccessor(node); }
            else {
                Node* temp = node->left;
                free(node);
                node = temp;
            }
        } else {
            if (hasRight) { Node* temp = node->right; free(node); node = temp; }
            else free(node);
        }
    }

private:

    Node* root;

    static void replaceWithSuccessor(Node* node) {
        Node *successor = node;
        while (successor->left != nullptr) successor = successor->left;
        node->data = successor->data;
        Node* temp = successor->right;
        free(successor);
        successor = temp;
    }

};


int main() {
    auto tree = BST();
    tree.insert(std::rand());
}
